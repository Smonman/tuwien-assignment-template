\documentclass[10pt]{article}
\usepackage{tuwienassignment}

%%%
%%% PLACE CUSTOM STYLES HERE
%%%
\usepackage{lipsum} % dummy text
\newcommand{\environmentcmd}[1]{\par\noindent\textbf{Environment:} \lstinline{#1}}
\newcommand{\commandcmd}[1]{\par\noindent\textbf{Command:} \lstinline{\\#1}}
\newcommand{\commandscmd}[2]{\par\noindent\textbf{Commands:} \lstinline{\\#1} and \lstinline{\\#2}}

\title{Title}
\author{Author}
\matrikelnr{12345678}

\begin{document}
\selectlanguage{english}
\maketitle

\section{Introduction}
\lipsum[1-1]

\subsection{Subsection}
\lipsum[2-3]

\subsubsection{Subsubsection}
\lipsum[2-3]

\paragraph{Paragraph}
\lipsum[1-2]

\subparagraph{Subparagraph}
\lipsum[1-2]

\section{Itemize and Enumerate}
\subsection{Itemize}
\begin{itemize}
  \item I am an item
  \item I am an item
  \item I am an item
        \begin{itemize}
          \item I am an item
          \item I am an item
          \item I am an item
                \begin{itemize}
                  \item I am an item
                  \item I am an item
                  \item I am an item
                \end{itemize}
        \end{itemize}
\end{itemize}

\subsection{Enumerate}
\begin{enumerate}
  \item I am an item
  \item I am an item
  \item I am an item
        \begin{enumerate}
          \item I am an item
          \item I am an item
          \item I am an item
                \begin{enumerate}
                  \item I am an item
                  \item I am an item
                  \item I am an item
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

\newpage
\section{Exercises and Solutions}
\environmentcmd{exercise} produces a numbered exercise, which prefixes the current section on their counter. The section can correspond to each exercise sheet for example.

\environmentcmd{solution} produces a numbered solution. A solution has to be placed \emph{inside} of the exercise. Solutions will be numbered accordingly inside of an exercise environment. The number for a solution can be changed by writing the macro \lstinline|\setcounter{solutioncounter}{x}| where \lstinline{x} is the number the counter should be set to.
The numberformat can also be changed by calling the macro \lstinline|\renewcommand{\thesolutioncounter}{x}| where \lstinline{x} is the format. For example for roman numerals it would be \lstinline|\roman{solutioncounter}|.

\begin{exercise}
  \lipsum[1-1]
  \begin{solution}
    \lipsum[1-1]
  \end{solution}
  \begin{solution}
    \lipsum[1-1]
  \end{solution}
  \begin{solution}
    \lipsum[1-1]
  \end{solution}
\end{exercise}

\begin{exercise}[title=Ãœbung]
  \lipsum[1-1]
  \begin{solution}
    \lipsum[1-1]
  \end{solution}
\end{exercise}

\begin{exercise}
  \renewcommand{\thesolutioncounter}{(\roman{solutioncounter})}%
  \lipsum[1-1]
  \begin{solution}
  \end{solution}
  \begin{solution}
  \end{solution}
\end{exercise}

\section{Math}
\subsection{Abs and Norm}
\commandscmd{abs}{norm}\footnote{see \url{https://tex.stackexchange.com/a/43009}} produce the following:
\begin{table}[h!t]
  \centering
  \begin{tabular}{ccc}
    \toprule
    \thead{command} & \thead{non-starred}       & \thead{starred}            \\
    \midrule
    \verb|\abs|     & \(\abs{\frac{1}{2}x^2}\)  & \(\abs*{\frac{1}{2}x^2}\)  \\
    \verb|\norm|    & \(\norm{\frac{1}{2}x^2}\) & \(\norm*{\frac{1}{2}x^2}\) \\
    \bottomrule
  \end{tabular}
\end{table}

The difference between \emph{starred} and \emph{non-starred} lies in the scaling of the bars.

\subsection{Sets and Tupels}
\commandcmd{mset} produces the following:
\[\mset{1, 2, 3, 4}\]
\[\mset{a \mid \frac{a}{2} > 5}\]
\[\mset{}\]
\[\mset{\mset{a}}\]

\commandcmd{mset*} produces the following:
\[\mset*{1, 2, 3, 4}\]
\[\mset*{a \mid \frac{a}{2} > 5}\]
\[\mset*{}\]

\commandcmd{msetmid} produces the following:
\[\msetmid{a}{\frac{a}{2} > 5}\]
This command automatically places a scaling mid symbol.

\commandcmd{msetmidsa} produces the following:
\[\mset{\msetmidsa}\]
This command has to be used inside of \lstinline{\mset} or \lstinline{\mset*}, and creates a \emph{standalone} scaling mid symbol. This allows for multiple mid symbols in one set e.g.: \(\mset{\msetmidsa \msetmidsa}\)

\commandcmd{mtupel} produces the following:
\[\mtupel{1, 2, 3, 4}\]
\[\mtupel{\frac{1}{2}, \frac{2}{3}}\]
\[\mtupel{}\]

\subsection{Other}

\commandcmd{mappliesto} produces the following with spacing:
\[\mappliesto\]
which can be used e.g. in the following context:
\[\mathbf{n}(u) = \frac{\sum_{i = 0}^n w_i \mathbf{d}_i N_i^k(u)}{\sum_{i = 0}^n w_i N_i^k(u)} \mappliesto u \in \left[u_0, u_{n + l}\right) \subset \mathbb{R}\]

\commandcmd{mdefinedas} produces the following:
\[\mdefinedas\]
which can be used e.g. in the following context:
\[\mathbf{b}_i^r \mdefinedas (1 - t) \cdot \mathbf{b}_i^{r - 1} + t \cdot \mathbf{b}_{i + 1}^{r - 1}\]

\subsection{Conditions}
\environmentcmd{conditions}\footnote{see \url{https://tex.stackexchange.com/a/95842}} can be used for the following:
\\
Boltzmann distribution: state occupation probability of a thermodynamical system within fixed temperature \(T\): \[p(x) = \alpha \cdot e^{-\frac{E(x)}{k \cdot T}}\] where:
\begin{conditions}
  x       & \sep & state \\
  \alpha  & \sep & degeneracy (= number of states \(x'\) with the same energy as \(x\)) \\
  E(x)    & \sep & energy \\
  k       & \sep & Bolzmann constant
\end{conditions}
It is possible to have different symbols instead of the dots:

\begin{conditions}[=]
  x       & \sep & state \\
  \alpha  & \sep & degeneracy (= number of states \(x'\) with the same energy as \(x\)) \\
  E(x)    & \sep & energy \\
  k       & \sep & Bolzmann constant
\end{conditions}

\section{Logic}
\subsection{Verum and Falsum}
\commandcmd{ltrue} produces the following:
\[\ltrue\]
\commandcmd{lfalse} produces the following:
\[\lfalse\]

\section{Tables}
\subsection{Itemize in Tables}
\environmentcmd{tabitemize} creates an itemize environment inside of an minipage, so it can be placed in a table cell:

\begin{table}[!h]
  \centering
  \begin{tabularx}{0.5\linewidth}{Y}
    \toprule
    Header            \\
    \midrule
    \begin{tabitemize}
      \item item 1
      \item item 2
      \item item 3
    \end{tabitemize} \\
    \bottomrule
  \end{tabularx}
\end{table}

Please note, that this only works in \emph{tabularx} columns.

\section{lstlistings}

\subsection{Python}
\begin{lstlisting}[caption=Example in Python,language=python]
import numpy as np
    
def incmatrix(genl1,genl2):
    m = len(genl1)
    n = len(genl2)
    M = None #to become the incidence matrix
    VT = np.zeros((n*m,1), int)  #dummy variable
    
    #compute the bitwise xor matrix
    M1 = bitxormatrix(genl1)
    M2 = np.triu(bitxormatrix(genl2),1) 

    for i in range(m-1):
        for j in range(i+1, m):
            [r,c] = np.where(M2 == M1[i,j])
            for k in range(len(r)):
                VT[(i)*n + r[k]] = 1;
                VT[(i)*n + c[k]] = 1;
                VT[(j)*n + r[k]] = 1;
                VT[(j)*n + c[k]] = 1;
                
                if M is None:
                    M = np.copy(VT)
                else:
                    M = np.concatenate((M, VT), 1)
                
                VT = np.zeros((n*m,1), int)
    
    return M
\end{lstlisting}

\subsection{C++}

\begin{lstlisting}[caption=Example in C++,language=c++]
#include <iostream>
using namespace std;

int main() {
    int n, t1 = 0, t2 = 1, nextTerm = 0;

    cout << "Enter the number of terms: ";
    cin >> n;

    cout << "Fibonacci Series: ";

    for (int i = 1; i <= n; ++i) {
        // Prints the first two terms.
        if(i == 1) {
            cout << t1 << ", ";
            continue;
        }
        if(i == 2) {
            cout << t2 << ", ";
            continue;
        }
        nextTerm = t1 + t2;
        t1 = t2;
        t2 = nextTerm;
        
        cout << nextTerm << ", ";
    }
    return 0;
}
\end{lstlisting}

\subsection{Output}

\begin{lstlisting}[style=lstoutput]
Enter a positive integer: 100
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 
\end{lstlisting}

\subsection{Pseudocode}

\begin{lstlisting}[caption=Example in Pseudo,language=pseudo]
function Tree-Search(problem) returns a solution, or failure
  initialize the frontier using the initial state of problem
  loop do
    if the frontier is empty then return failure
    choose a leaf node and remove it from the frontier
    if the node contains a goal state then return the corresponding solution
    expand the chosen node, adding the resulting nodes to the frontier
\end{lstlisting}

\subsection{Standard}

\begin{lstlisting}[caption=Very long line]
This is a very very very very very very very very very very very very very very very very very very very very very long line.
\end{lstlisting}

\subsection{File Input}
\lstinputlisting[caption=Example in C,language=C]{example.c}

\section{Images}
Take a look at this example image: \footnote{Copyright free image from \url{https://pixabay.com/illustrations/background-pattern-lemon-texture-6703215/}}
\begin{figure}[h!t]
  \centering
  \includegraphics[scale=0.5]{happy_lemons.png}
  \caption{Happy Lemons}
  \label{fig:happylemons}
\end{figure}

\end{document}